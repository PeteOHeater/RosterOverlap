<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pilot Roster Overlap Analyzer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 40px;
        }

        .section-title {
            font-size: 1.5em;
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #f8f9ff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            background: #f0f2ff;
            border-color: #764ba2;
        }

        .upload-area.dragover {
            background: #e8ebff;
            border-color: #764ba2;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            display: inline-block;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-danger {
            background: #dc3545;
        }

        .pilot-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .pilot-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid #667eea;
            transition: transform 0.2s;
        }

        .pilot-card:hover {
            transform: translateX(5px);
        }

        .pilot-name {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .pilot-details {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 15px;
        }

        .pilot-location {
            margin-top: 15px;
        }

        .pilot-location label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }

        .pilot-location input,
        .pilot-location select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.95em;
        }

        .overlap-results {
            margin-top: 30px;
        }

        .overlap-card {
            background: linear-gradient(135deg, #f8f9ff 0%, #fff 100%);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 5px solid #28a745;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .overlap-card.off-day {
            border-left-color: #17a2b8;
            background: linear-gradient(135deg, #e0f7fa 0%, #fff 100%);
        }

        .overlap-card.warning {
            border-left-color: #ffc107;
        }

        .overlap-date {
            font-size: 1.3em;
            font-weight: 700;
            color: #333;
            margin-bottom: 10px;
        }

        .overlap-location {
            font-size: 1.1em;
            color: #667eea;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .overlap-pilots {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
        }

        .pilot-schedule {
            background: white;
            padding: 12px 15px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            flex: 1;
            min-width: 200px;
        }

        .pilot-schedule-name {
            font-weight: 700;
            color: #764ba2;
            margin-bottom: 5px;
        }

        .pilot-schedule-time {
            color: #555;
            font-size: 0.95em;
        }

        .overlap-duration {
            background: #28a745;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            display: inline-block;
            font-weight: 600;
            font-size: 0.9em;
        }

        .overlap-duration.off-day {
            background: #17a2b8;
        }

        .no-overlaps {
            text-align: center;
            padding: 40px;
            color: #999;
            font-size: 1.1em;
        }

        .stats-bar {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 8px;
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .stat {
            text-align: center;
            padding: 10px;
        }

        .stat-number {
            font-size: 2em;
            font-weight: 700;
            color: #667eea;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .info-box strong {
            color: #1976D2;
        }

        .section-subtitle {
            font-size: 1.1em;
            color: #666;
            margin-bottom: 15px;
            font-style: italic;
        }

        @media (max-width: 768px) {
            .content {
                padding: 15px;
            }

            .pilot-list {
                grid-template-columns: 1fr;
            }

            .stats-bar {
                flex-direction: column;
            }

            .overlap-pilots {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚úàÔ∏è Pilot Roster Overlap Analyzer</h1>
            <p>Find when crew members are in the same location</p>
        </div>

        <div class="content">
            <!-- Upload Section -->
            <div class="section">
                <h2 class="section-title">üì§ Upload Rosters</h2>
                <div class="info-box">
                    <strong>Note:</strong> Upload Qantas ARMS roster files (.txt format). Each pilot should upload their own roster. 
                    Files are processed locally in your browser - no data is sent to any server.
                </div>
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">üìÅ</div>
                    <h3>Drop roster files here or click to browse</h3>
                    <p>Supports up to 10 pilots</p>
                    <input type="file" id="fileInput" accept=".txt" multiple>
                </div>
                <div style="margin-top: 20px; text-align: center;">
                    <button class="btn" onclick="document.getElementById('fileInput').click()">
                        Browse Files
                    </button>
                    <button class="btn btn-secondary" onclick="clearAllData()">
                        Clear All Data
                    </button>
                </div>
            </div>

            <!-- Pilots Section -->
            <div class="section" id="pilotsSection" style="display: none;">
                <h2 class="section-title">üë®‚Äç‚úàÔ∏è Loaded Pilots</h2>
                <div id="pilotsList" class="pilot-list"></div>
            </div>

            <!-- Analysis Button -->
            <div class="section" id="analyzeSection" style="display: none; text-align: center;">
                <button class="btn" onclick="analyzeOverlaps()" style="font-size: 1.2em; padding: 15px 40px;">
                    üîç Find Overlaps
                </button>
            </div>

            <!-- Off Days Section -->
            <div class="section" id="offDaysSection" style="display: none;">
                <h2 class="section-title">üèñÔ∏è Days Off / Available / Leave Overlap</h2>
                <p class="section-subtitle">Times when pilots are off duty on the same dates (regardless of location)</p>
                <div id="offDaysResults" class="overlap-results"></div>
            </div>

            <!-- Location Overlap Results Section -->
            <div class="section" id="resultsSection" style="display: none;">
                <h2 class="section-title">üìç Same Location Overlaps</h2>
                <p class="section-subtitle">Times when pilots are in the same city with 30+ minutes overlap</p>
                <div class="stats-bar" id="statsBar"></div>
                <div id="overlapResults" class="overlap-results"></div>
            </div>
        </div>
    </div>

    <script>
        // Global storage for pilot data
        let pilotsData = [];
        const STORAGE_KEY = 'pilotRosterData';
        const LOCATIONS_KEY = 'pilotLocations';

        // Common airport codes for Australia
        const AIRPORT_NAMES = {
            'ADL': 'Adelaide',
            'SYD': 'Sydney',
            'MEL': 'Melbourne',
            'BNE': 'Brisbane',
            'PER': 'Perth',
            'OOL': 'Gold Coast',
            'CBR': 'Canberra',
            'DRW': 'Darwin',
            'HBA': 'Hobart',
            'CNS': 'Cairns',
            'AKL': 'Auckland',
            'WLG': 'Wellington',
            'CHC': 'Christchurch',
            'HTI': 'Hamilton Island',
            'JFK': 'New York'
        };

        const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

        // Load saved data on page load
        window.addEventListener('DOMContentLoaded', () => {
            loadSavedData();
            setupEventListeners();
        });

        function setupEventListeners() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            uploadArea.addEventListener('click', () => fileInput.click());

            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                handleFiles(e.dataTransfer.files);
            });

            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
            });
        }

        function handleFiles(files) {
            if (files.length === 0) return;

            if (pilotsData.length + files.length > 10) {
                alert('Maximum 10 pilots supported. Please remove some rosters first.');
                return;
            }

            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        parseRoster(e.target.result, file.name);
                    } catch (error) {
                        console.error('Error parsing roster:', error);
                        alert(`Error parsing ${file.name}: ${error.message}`);
                    }
                };
                reader.readAsText(file);
            });
        }

        function parseRoster(content, filename) {
            const pilot = {
                id: Date.now() + Math.random(),
                filename: filename,
                name: '',
                staffNo: '',
                category: '',
                base: '',
                rosterType: '',
                rosterStart: null,
                schedule: []
            };

            // Extract pilot information
            const nameMatch = content.match(/Name\s*:\s*([A-Z\s]+?)\s+Staff/i);
            if (nameMatch) pilot.name = nameMatch[1].trim();

            const staffMatch = content.match(/Staff No:\s*(\d+)/);
            if (staffMatch) pilot.staffNo = staffMatch[1];

            const categoryMatch = content.match(/Category:\s*(CPT-B\d+)/);
            if (categoryMatch) {
                pilot.category = categoryMatch[1];
                pilot.rosterType = categoryMatch[1].includes('787') ? 'Long Haul' : 'Short Haul';
            }

            const baseMatch = content.match(/Base\s*:\s*([A-Z]{3})/);
            if (baseMatch) pilot.base = baseMatch[1];

            // Parse schedule with dates
            pilot.schedule = parseSchedule(content, pilot.rosterType);

            // Find roster start date
            if (pilot.schedule.length > 0) {
                pilot.rosterStart = pilot.schedule[0].fullDate;
            }

            // Add to pilots data
            pilotsData.push(pilot);
            saveData();
            updateUI();
        }

        function parseSchedule(content, rosterType) {
            const schedule = [];
            const lines = content.split('\n');

            // Detect year and month from content
            let currentYear = 2026;
            let currentMonth = null;

            // Try to find date in header
            const headerDateMatch = content.match(/(\d{2})(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)(\d{2})/);
            if (headerDateMatch) {
                currentYear = 2000 + parseInt(headerDateMatch[3]);
            }

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                // Short haul format: "DD DayOfWeek DUTY ..."
                const shPattern = /^(\d{2})\s+(Mon|Tue|Wed|Thu|Fri|Sat|Sun)\s+(\S+)(.*)$/;
                const shMatch = line.match(shPattern);

                if (shMatch) {
                    const [, day, dow, duty, rest] = shMatch;

                    // Extract times if present
                    const timeMatch = rest.match(/(\d{4})\s+(\d{4})/);
                    let startTime = null;
                    let endTime = null;

                    if (timeMatch) {
                        startTime = timeMatch[1];
                        endTime = timeMatch[2];
                    }

                    // Extract ports
                    const ports = extractPorts(line);

                    // Determine month if we haven't yet or if day wrapped
                    if (currentMonth === null) {
                        // First entry - try to find from flight details
                        const flightDateMatch = content.match(new RegExp(day + '([A-Z][a-z]{2})'));
                        if (flightDateMatch) {
                            currentMonth = MONTHS.indexOf(flightDateMatch[1]);
                        } else {
                            currentMonth = 0; // Default to January
                        }
                    } else if (schedule.length > 0) {
                        const prevDay = parseInt(schedule[schedule.length - 1].date);
                        const currDay = parseInt(day);
                        if (currDay < prevDay) {
                            // Month rolled over
                            currentMonth = (currentMonth + 1) % 12;
                            if (currentMonth === 0) currentYear++;
                        }
                    }

                    const fullDate = new Date(currentYear, currentMonth, parseInt(day));

                    schedule.push({
                        date: day,
                        dayOfWeek: dow,
                        duty: duty,
                        startTime: startTime,
                        endTime: endTime,
                        ports: ports,
                        type: duty === 'D/O' ? 'OFF' : duty === 'AV' ? 'AVAILABLE' : duty === 'AL' ? 'LEAVE' : 'DUTY',
                        fullDate: fullDate
                    });
                }

                // Long haul format: "DD/MM D TYPE"
                const lhPattern = /^(\d{2})\/(\d{2})\s+[A-Z]\s+(\S+)/;
                const lhMatch = line.match(lhPattern);

                if (lhMatch) {
                    const [, day, month, type] = lhMatch;
                    const fullDate = new Date(currentYear, parseInt(month) - 1, parseInt(day));

                    schedule.push({
                        date: day,
                        duty: type,
                        type: type === 'AL' ? 'LEAVE' : type.includes('NN') || type.includes('TR') ? 'DUTY' : 'OTHER',
                        fullDate: fullDate
                    });
                }
            }

            // Parse detailed flight information
            const flightDetails = parseFlightDetails(content);
            schedule.forEach(day => {
                if (day.type === 'DUTY' && flightDetails[day.date]) {
                    day.flights = flightDetails[day.date];
                    // If we have flight details, extract more ports
                    flightDetails[day.date].forEach(flight => {
                        if (flight.from && !day.ports.includes(flight.from)) {
                            day.ports.push(flight.from);
                        }
                        if (flight.to && !day.ports.includes(flight.to)) {
                            day.ports.push(flight.to);
                        }
                    });
                }
            });

            return schedule;
        }

        function extractPorts(line) {
            const ports = [];
            const portMatches = line.matchAll(/\b([A-Z]{3})\b/g);
            for (const match of portMatches) {
                const code = match[1];
                if (AIRPORT_NAMES[code] && !ports.includes(code)) {
                    ports.push(code);
                }
            }
            return ports;
        }

        function parseFlightDetails(content) {
            const flights = {};
            const lines = content.split('\n');

            const flightPattern = /(\d{2})([A-Z][a-z]{2})\s+(\d+)\s+([A-Z]{3})\s+(\d{4})\s+([A-Z]{3})\s+(\d{4})/;

            for (const line of lines) {
                const match = line.match(flightPattern);
                if (match) {
                    const [, day, month, flightNum, from, depTime, to, arrTime] = match;

                    if (!flights[day]) flights[day] = [];

                    flights[day].push({
                        from: from,
                        to: to,
                        departure: depTime,
                        arrival: arrTime
                    });
                }
            }

            return flights;
        }

        function saveData() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(pilotsData));
        }

        function loadSavedData() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                pilotsData = JSON.parse(saved);
                // Restore Date objects
                pilotsData.forEach(pilot => {
                    pilot.schedule.forEach(day => {
                        if (day.fullDate) {
                            day.fullDate = new Date(day.fullDate);
                        }
                    });
                    if (pilot.rosterStart) {
                        pilot.rosterStart = new Date(pilot.rosterStart);
                    }
                });
                updateUI();
            }
        }

        function updateUI() {
            const pilotsSection = document.getElementById('pilotsSection');
            const analyzeSection = document.getElementById('analyzeSection');
            const pilotsList = document.getElementById('pilotsList');

            if (pilotsData.length === 0) {
                pilotsSection.style.display = 'none';
                analyzeSection.style.display = 'none';
                return;
            }

            pilotsSection.style.display = 'block';
            analyzeSection.style.display = 'block';

            pilotsList.innerHTML = pilotsData.map(pilot => {
                const savedLocation = getSavedLocation(pilot.id);
                const startDate = pilot.rosterStart ? pilot.rosterStart.toLocaleDateString('en-AU', {day: 'numeric', month: 'short', year: 'numeric'}) : 'Unknown';

                return `
                    <div class="pilot-card">
                        <div class="pilot-name">${pilot.name || 'Unknown'}</div>
                        <div class="pilot-details">
                            <div>Staff #: ${pilot.staffNo}</div>
                            <div>Type: ${pilot.rosterType}</div>
                            <div>Base: ${pilot.base}</div>
                            <div>Roster Start: ${startDate}</div>
                            <div>Schedule: ${pilot.schedule.length} days</div>
                        </div>
                        <div class="pilot-location">
                            <label>Location on Days Off/Available/Leave:</label>
                            <select onchange="savePilotLocation('${pilot.id}', this.value)" id="location-${pilot.id}">
                                <option value="">Select location...</option>
                                ${Object.entries(AIRPORT_NAMES).map(([code, name]) => 
                                    `<option value="${code}" ${savedLocation === code ? 'selected' : ''}>${name} (${code})</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div style="margin-top: 15px;">
                            <button class="btn btn-danger" onclick="removePilot('${pilot.id}')" style="width: 100%;">
                                Remove Roster
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getSavedLocation(pilotId) {
            const locations = JSON.parse(localStorage.getItem(LOCATIONS_KEY) || '{}');
            return locations[pilotId] || '';
        }

        function savePilotLocation(pilotId, location) {
            const locations = JSON.parse(localStorage.getItem(LOCATIONS_KEY) || '{}');
            locations[pilotId] = location;
            localStorage.setItem(LOCATIONS_KEY, JSON.stringify(locations));
        }

        function removePilot(pilotId) {
            pilotsData = pilotsData.filter(p => p.id != pilotId);
            saveData();
            updateUI();
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('offDaysSection').style.display = 'none';
        }

        function clearAllData() {
            if (confirm('Are you sure you want to clear all pilot data and location settings?')) {
                pilotsData = [];
                localStorage.removeItem(STORAGE_KEY);
                localStorage.removeItem(LOCATIONS_KEY);
                updateUI();
                document.getElementById('resultsSection').style.display = 'none';
                document.getElementById('offDaysSection').style.display = 'none';
            }
        }

        function analyzeOverlaps() {
            const offDayOverlaps = findOffDayOverlaps();
            const locationOverlaps = findLocationOverlaps();

            displayOffDayOverlaps(offDayOverlaps);
            displayLocationOverlaps(locationOverlaps);
        }

        function findOffDayOverlaps() {
            const overlaps = [];

            // Create date map for off days
            const dateMap = {};

            pilotsData.forEach(pilot => {
                pilot.schedule.forEach(day => {
                    if (day.type === 'OFF' || day.type === 'AVAILABLE' || day.type === 'LEAVE') {
                        const dateKey = day.fullDate.toISOString().split('T')[0];

                        if (!dateMap[dateKey]) {
                            dateMap[dateKey] = [];
                        }

                        dateMap[dateKey].push({
                            pilot: pilot,
                            day: day,
                            status: day.type
                        });
                    }
                });
            });

            // Find overlaps (2+ pilots off on same day)
            Object.entries(dateMap).forEach(([dateKey, pilots]) => {
                if (pilots.length < 2) return;

                // Create all combinations of pilot pairs
                for (let i = 0; i < pilots.length; i++) {
                    for (let j = i + 1; j < pilots.length; j++) {
                        overlaps.push({
                            date: new Date(dateKey),
                            pilots: [pilots[i], pilots[j]]
                        });
                    }
                }
            });

            // Sort by date
            overlaps.sort((a, b) => a.date - b.date);

            return overlaps;
        }

        function findLocationOverlaps() {
            const overlaps = [];
            const locationMap = {};

            // Build location map for each day
            pilotsData.forEach(pilot => {
                const homeLocation = getSavedLocation(pilot.id);

                pilot.schedule.forEach(day => {
                    let locations = [];
                    let startTime = null;
                    let endTime = null;
                    let status = '';

                    if (day.type === 'OFF' || day.type === 'AVAILABLE' || day.type === 'LEAVE') {
                        if (homeLocation) {
                            locations = [homeLocation];
                            startTime = '0000';
                            endTime = '2359';
                            status = day.type;
                        }
                    } else if (day.type === 'DUTY' && day.ports && day.ports.length > 0) {
                        locations = day.ports;
                        startTime = day.startTime || '0000';
                        endTime = day.endTime || '2359';
                        status = 'DUTY';
                    }

                    locations.forEach(location => {
                        const dateKey = day.fullDate.toISOString().split('T')[0];
                        const key = `${dateKey}-${location}`;

                        if (!locationMap[key]) locationMap[key] = [];

                        locationMap[key].push({
                            pilot: pilot,
                            day: day,
                            location: location,
                            startTime: startTime,
                            endTime: endTime,
                            status: status
                        });
                    });
                });
            });

            // Find overlaps (2+ pilots in same location on same day)
            Object.entries(locationMap).forEach(([key, pilots]) => {
                if (pilots.length < 2) return;

                const [dateKey, location] = key.split('-');

                // Check for time overlap between all pilot pairs
                for (let i = 0; i < pilots.length; i++) {
                    for (let j = i + 1; j < pilots.length; j++) {
                        const overlap = calculateOverlap(pilots[i], pilots[j]);
                        if (overlap && overlap.minutes >= 30) {
                            overlaps.push({
                                date: new Date(dateKey),
                                location: location,
                                pilots: [pilots[i], pilots[j]],
                                overlapMinutes: overlap.minutes,
                                overlapStart: overlap.start,
                                overlapEnd: overlap.end
                            });
                        }
                    }
                }
            });

            // Sort by date
            overlaps.sort((a, b) => a.date - b.date);

            return overlaps;
        }

        function calculateOverlap(pilot1, pilot2) {
            if (!pilot1.startTime || !pilot2.startTime) return null;

            const start1 = parseInt(pilot1.startTime);
            const end1 = parseInt(pilot1.endTime);
            const start2 = parseInt(pilot2.startTime);
            const end2 = parseInt(pilot2.endTime);

            const overlapStart = Math.max(start1, start2);
            const overlapEnd = Math.min(end1, end2);

            if (overlapStart >= overlapEnd) return null;

            // Calculate minutes
            const startHours = Math.floor(overlapStart / 100);
            const startMins = overlapStart % 100;
            const endHours = Math.floor(overlapEnd / 100);
            const endMins = overlapEnd % 100;

            const totalMins = (endHours * 60 + endMins) - (startHours * 60 + startMins);

            return {
                minutes: totalMins,
                start: overlapStart,
                end: overlapEnd
            };
        }

        function displayOffDayOverlaps(overlaps) {
            const offDaysSection = document.getElementById('offDaysSection');
            const offDaysResults = document.getElementById('offDaysResults');

            if (overlaps.length === 0) {
                offDaysSection.style.display = 'none';
                return;
            }

            offDaysSection.style.display = 'block';

            offDaysResults.innerHTML = overlaps.map(overlap => {
                const dateStr = overlap.date.toLocaleDateString('en-AU', {
                    weekday: 'short',
                    day: 'numeric',
                    month: 'short',
                    year: 'numeric'
                });

                return `
                    <div class="overlap-card off-day">
                        <div class="overlap-date">üìÖ ${dateStr}</div>
                        <div class="overlap-pilots">
                            ${overlap.pilots.map(p => `
                                <div class="pilot-schedule">
                                    <div class="pilot-schedule-name">${p.pilot.name}</div>
                                    <div class="pilot-schedule-time">
                                        ${p.status} - All Day
                                        ${p.status === 'OFF' ? '(Day Off)' : p.status === 'AVAILABLE' ? '(Available)' : '(Annual Leave)'}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <div>
                            <span class="overlap-duration off-day">‚è±Ô∏è Full Day Overlap</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function displayLocationOverlaps(overlaps) {
            const resultsSection = document.getElementById('resultsSection');
            const statsBar = document.getElementById('statsBar');
            const overlapResults = document.getElementById('overlapResults');

            resultsSection.style.display = 'block';

            // Display stats
            const uniqueDates = new Set(overlaps.map(o => o.date.toISOString().split('T')[0])).size;
            const uniqueLocations = new Set(overlaps.map(o => o.location)).size;

            statsBar.innerHTML = `
                <div class="stat">
                    <div class="stat-number">${overlaps.length}</div>
                    <div class="stat-label">Location Overlaps</div>
                </div>
                <div class="stat">
                    <div class="stat-number">${uniqueDates}</div>
                    <div class="stat-label">Unique Days</div>
                </div>
                <div class="stat">
                    <div class="stat-number">${uniqueLocations}</div>
                    <div class="stat-label">Locations</div>
                </div>
            `;

            if (overlaps.length === 0) {
                overlapResults.innerHTML = '<div class="no-overlaps">No location overlaps found with at least 30 minutes. Try setting pilot home locations for days off.</div>';
                return;
            }

            overlapResults.innerHTML = overlaps.map(overlap => {
                const hours = Math.floor(overlap.overlapMinutes / 60);
                const mins = overlap.overlapMinutes % 60;
                const durationText = hours > 0 ? `${hours}h ${mins}m` : `${mins}m`;

                const dateStr = overlap.date.toLocaleDateString('en-AU', {
                    weekday: 'short',
                    day: 'numeric',
                    month: 'short',
                    year: 'numeric'
                });

                return `
                    <div class="overlap-card">
                        <div class="overlap-date">üìÖ ${dateStr}</div>
                        <div class="overlap-location">üìç ${AIRPORT_NAMES[overlap.location] || overlap.location}</div>
                        <div class="overlap-pilots">
                            ${overlap.pilots.map(p => `
                                <div class="pilot-schedule">
                                    <div class="pilot-schedule-name">${p.pilot.name}</div>
                                    <div class="pilot-schedule-time">
                                        ${formatTime(p.startTime)} - ${formatTime(p.endTime)}
                                        <br><small>${p.status}</small>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <div>
                            <span class="overlap-duration">‚è±Ô∏è ${durationText} overlap</span>
                            <small style="margin-left: 15px; color: #666;">
                                ${formatTime(overlap.overlapStart)} - ${formatTime(overlap.overlapEnd)}
                            </small>
                        </div>
                    </div>
                `;
            }).join('');

            // Scroll to results
            resultsSection.scrollIntoView({ behavior: 'smooth' });
        }

        function formatTime(time) {
            if (!time) return 'N/A';
            const timeStr = time.toString().padStart(4, '0');
            return `${timeStr.substring(0, 2)}:${timeStr.substring(2)}`;
        }
    </script>
</body>
</html>
